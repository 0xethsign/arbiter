# Middleware
The `RevmMiddleware` is the main interface for interacting with an `Environment`.
We implement the `ethers-rs` `Middleware` trait so that you may work with contract bindings generated by `forge` or `arbiter bind` as if you were interacting with a live network.
Not all methods are implemented, but the relevant ones are.

`RevmMiddleware` owns a `Connection` which is the client's interface to the `Environment`'s `Socket`.
This `Connection` acts much like a WebSocket connection and is used to send `Instruction`s and receive their outcome from the `Environment` as well as subscribe to events.
To make this `Connection` and `RevmMiddleware` flexible, we also implement (for both) the `JsonRpcClient` and `PubSubClient` traits.

We also provide `RevmMiddleware` a wallet so that it can be associated to an account in the `Environment`'s world state.
The `wallet: EOA` field of `RevmMiddleware` is decided upon creation of the `RevmMiddleware` and, if the wallet is generated from calling `RevmMiddleware::new()`, wallet will be of `EOA::Wallet(Wallet<SigningKey>)` which allows for `RevmMiddleware` to sign transactions if need be.
It is possible to create accounts from a forked database, in which case you would call `RevmMiddleware::new_from_forked_eoa()` and the wallet would be of `EOA::Forked(Address)`.
This type is unable to sign as it is effectively impossible to recover the signing key from an address.
Fortunately, for almost every usecase of `RevmMiddleware`, you will not need to sign transactions, so this distinction does not matter.

## Usage

To create a `RevmMiddleware` that is associated with an account in the `Environment`'s world state, we can do the following:
```rust
use arbiter_core::middleware::RevmMiddleware;
use arbiter_core::environment::builder::EnvironmentBuilder;

fn main() {
    let env = EnvironmentBuilder::new().build();

    // Create a client for the above `Environment` with an ID
    let id = "alice";
    let alice = RevmMiddleware::new(&env, Some(id));

    // Create a client without an ID
    let client = RevmMiddleware::new(&env, None);
}
```
These created clients can then get access to making calls and transactions to contracts deployed into the `Environment`'s world state. We can do the following:
```rust
use arbiter_core::middleware::RevmMiddleware;
use arbiter_core::environment::builder::EnvironmentBuilder;
use arbiter_bindings::bindings::arbiter_token::ArbiterToken;

#[tokio::main]
async fn main() {
    let env = EnvironmentBuilder::new().build();
    let client = RevmMiddleware::new(&env, None).unwrap();

    // Deploy a contract
    let contract = ArbiterToken::deploy(client, ("ARBT".to_owned(), "Arbiter Token".to_owned(), 18u8)).unwrap().send().await.unwrap();
}
```
