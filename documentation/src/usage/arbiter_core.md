# Arbiter Core
The `arbiter-core` crate is the core of the Arbiter framework. 
It contains the `Environment` struct which acts as an EVM sandbox and the `RevmMiddleware` which gives a convenient interface for interacting with contracts deployed into the `Environment`.
The API provided by `RevmMiddleware` is that of the `Middleware` trait in the `ethers-rs` crate, therefore it looks and feels just like you're interacting with a live network when you work with an Arbiter `Environment`. 
The only notable differences are in the control you have over this `Environment` compared to something like Anvil, a testnet, or a live network.

## Environment
The `Environment` owns a `revm` instance for processing EVM bytecode.
To make the `Environment` performant and flexible, it runs on its own system thread and receives all communication via `Instruction`s sent to it via a `Sender<Instruction>`.
The `Socket` is a struct owned by the `Environment` that manages all inward and outward communication with the `Environment`'s clients, such as the `Instruction` channel.

### Usage
To create an `Environment`, we use a builder pattern that allows you to pre-load an `Environment` with your own database.
We can do the following to create a default `Environment`:
```rust
use arbiter_core::environment::builder::EnvironmentBuilder;

fn main() {
    let env = EnvironmentBuilder::new().build();
}
```
Note that the call to `.build()` will start the `Environment`'s thread and begin processing `Instruction`s.

If you have a database that has been forked from a live network, it has likely been serialized to disk.
In which case, you can do something like this:
```rust, ignore
use arbiter_core::environment::builder::EnvironmentBuilder;
use arbiter_core::environment::fork::Fork;

fn main() {
    let path_to_fork = "path/to/fork";
    let fork = Fork::from_disk(path_to_fork).unwrap();
    let env = EnvironmentBuilder::new().db(fork).build();
}
```
This will create an `Environment` that has been forked from the database at the given path and is ready to receive `Instruction`s.

### Instructions
`Instruction`s have been added to over time, but at the moment we allow for the following:
- `Instruction::AddAccount`: Add an account to the `Environment`'s world state. This is usually called by the `RevmMiddleware` when a new client is created.
- `Instruction::BlockUpdate`: Update the `Environment`'s block number and block timestamp. This can be handled by an external agent in a simulation, if desired.
- `Instruction::Cheatcode`: Execute one of the `Cheatcodes` on the `Environment`'s world state. 
The `Cheatcodes` include:
    - `Cheatcodes::Deal`: Used to set the raw ETH balance of a user. Useful when you need to pay gas fees in a transaction.
    - `Cheatcodes::Load`: Gets the value of a storage slot of an account. 
    - `Cheatcodes::Store`: Sets the value of a storage slot of an account.
    - `Cheatcodes::Access`: Gets the account at an address.
- `Instruction::Query`: Allows for querying the `Environment`'s world state and current configuration. Anything in the `EnvironmentData` enum is accessible via this instruction.
    - `EnvironmentData::BlockNumber`: Gets the current block number of the `Environment`.
    - `EnvironmentData::BlockTimestamp`: Gets the current block timestamp of the `Environment`.
    - `EnvironmentData::GasPrice`: Gets the current gas price of the `Environment`.
    - `EnvironmentData::Balance`: Gets the current ETH balance of an account.
    - `EnvironmentData::TransactionCount`: Gets the current nonce of an account.
- `Instruction::Stop`: Stops the `Environment`'s thread and echos out to any listeners to shut down their event streams. This can be used when handling errors or reverts, or just when you're done with the `Environment`.
- `Instruction::Transaction`: Executes a transaction on the `Environment`'s world state. This is usually called by the `RevmMiddleware` when a client sends a ETH-call or state-changing transaction.

The `RevmMiddleware` provides methods for sending the above instructions to an associated `Environment` so that you do not have to interact with the `Environment` directly!

### Events
The `Environment` also emits Ethereum events and errors/reverts to clients who are set to listen to them. 
To do so, we use a `tokio::sync::broadcast` channel and the `RevmMiddleware` manages subscriptions to these events.
As for errors or reverts, we are working on making the flow of handling these more graceful so that your own program or agents can decide how to handle them.

## RevmMiddleware
The `RevmMiddleware` is the main interface for interacting with an `Environment`.
We implement the `ethers-rs` `Middleware` trait so that you may work with contract bindings generated by `forge` or `arbiter bind` as if you were interacting with a live network.
Not all methods are implemented, but the relevant ones are.

`RevmMiddleware` owns a `Connection` which is the client's interface to the `Environment`'s `Socket`.
This `Connection` acts much like a WebSocket connection and is used to send `Instruction`s and receive their outcome from the `Environment` as well as subscribe to events.
To make this `Connection` and `RevmMiddleware` flexible, we also implement (for both) the `JsonRpcClient` and `PubSubClient` traits.

We also provide `RevmMiddleware` a wallet so that it can be associated to an account in the `Environment`'s world state.
The `wallet: EOA` field of `RevmMiddleware` is decided upon creation of the `RevmMiddleware` and, if the wallet is generated from calling `RevmMiddleware::new()`, wallet will be of `EOA::Wallet(Wallet<SigningKey>)` which allows for `RevmMiddleware` to sign transactions if need be.
It is possible to create accounts from a forked database, in which case you would call `RevmMiddleware::new_from_forked_eoa()` and the wallet would be of `EOA::Forked(Address)`.
This type is unable to sign as it is effectively impossible to recover the signing key from an address.
Fortunately, for almost every usecase of `RevmMiddleware`, you will not need to sign transactions, so this distinction does not matter.

### Usage

To create a `RevmMiddleware` that is associated with an account in the `Environment`'s world state, we can do the following:
```rust
use arbiter_core::middleware::RevmMiddleware;
use arbiter_core::environment::builder::EnvironmentBuilder;

fn main() {
    let env = EnvironmentBuilder::new().build();

    // Create a client for the above `Environment` with an ID
    let id = "alice";
    let alice = RevmMiddleware::new(&env, Some(id));

    // Create a client without an ID
    let client = RevmMiddleware::new(&env, None);
}
```
These created clients can then get access to making calls and transactions to contracts deployed into the `Environment`'s world state. We can do the following:
```rust
use arbiter_core::middleware::RevmMiddleware;
use arbiter_core::environment::builder::EnvironmentBuilder;
use arbiter_bindings::bindings::arbiter_token::ArbiterToken;

#[tokio::main]
async fn main() {
    let env = EnvironmentBuilder::new().build();
    let client = RevmMiddleware::new(&env, None).unwrap();

    // Deploy a contract
    let contract = ArbiterToken::deploy(client, ("ARBT".to_owned(), "Arbiter Token".to_owned(), 18u8)).unwrap().send().await.unwrap();
}
```
